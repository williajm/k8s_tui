# K8S-TUI Test Resources
# This file creates a variety of Kubernetes resources for manual testing of the TUI
# Apply with: kubectl apply -f test-resources.yaml
# Delete with: kubectl delete -f test-resources.yaml

---
# Test Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: k8s-tui-test
  labels:
    app: k8s-tui-test

---
# ConfigMap for nginx configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  namespace: k8s-tui-test
data:
  index.html: |
    <html>
    <head><title>K8S-TUI Test</title></head>
    <body><h1>Hello from K8S-TUI Test!</h1></body>
    </html>

---
# Deployment 1: Healthy nginx deployment (3 replicas, all ready)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-healthy
  namespace: k8s-tui-test
  labels:
    app: nginx
    env: test
    status: healthy
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  selector:
    matchLabels:
      app: nginx
      env: test
  template:
    metadata:
      labels:
        app: nginx
        env: test
    spec:
      containers:
      - name: nginx
        image: nginx:1.25-alpine
        ports:
        - containerPort: 80
          name: http
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10

---
# Deployment 2: Single replica deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-single
  namespace: k8s-tui-test
  labels:
    app: redis
    env: test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
      env: test
  template:
    metadata:
      labels:
        app: redis
        env: test
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
          name: redis
        resources:
          requests:
            cpu: 50m
            memory: 64Mi

---
# Deployment 3: Zero replicas (scaled down)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-scaled-down
  namespace: k8s-tui-test
  labels:
    app: test-app
    env: test
    status: scaled-down
spec:
  replicas: 0
  selector:
    matchLabels:
      app: test-app
      env: test
  template:
    metadata:
      labels:
        app: test-app
        env: test
    spec:
      containers:
      - name: app
        image: busybox:latest
        command: ['sh', '-c', 'echo "Hello" && sleep 3600']

---
# StatefulSet 1: Postgres cluster (3 replicas)
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-cluster
  namespace: k8s-tui-test
  labels:
    app: postgres
    env: test
spec:
  serviceName: postgres-headless
  replicas: 3
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: postgres
      env: test
  template:
    metadata:
      labels:
        app: postgres
        env: test
    spec:
      containers:
      - name: postgres
        image: postgres:16-alpine
        ports:
        - containerPort: 5432
          name: postgres
        env:
        - name: POSTGRES_PASSWORD
          value: testpassword
        - name: POSTGRES_DB
          value: testdb
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi

---
# StatefulSet 2: Redis cluster (smaller, 2 replicas)
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
  namespace: k8s-tui-test
  labels:
    app: redis-cluster
    env: test
spec:
  serviceName: redis-cluster-headless
  replicas: 2
  updateStrategy:
    type: OnDelete
  selector:
    matchLabels:
      app: redis-cluster
      env: test
  template:
    metadata:
      labels:
        app: redis-cluster
        env: test
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
          name: redis
        resources:
          requests:
            cpu: 50m
            memory: 128Mi

---
# Service 1: ClusterIP for nginx
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  namespace: k8s-tui-test
  labels:
    app: nginx
spec:
  type: ClusterIP
  selector:
    app: nginx
    env: test
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http

---
# Service 2: NodePort for nginx (accessible from outside)
apiVersion: v1
kind: Service
metadata:
  name: nginx-nodeport
  namespace: k8s-tui-test
  labels:
    app: nginx
spec:
  type: NodePort
  selector:
    app: nginx
    env: test
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30080
    protocol: TCP
    name: http

---
# Service 3: Headless service for postgres
apiVersion: v1
kind: Service
metadata:
  name: postgres-headless
  namespace: k8s-tui-test
  labels:
    app: postgres
spec:
  clusterIP: None
  selector:
    app: postgres
    env: test
  ports:
  - port: 5432
    targetPort: 5432
    protocol: TCP
    name: postgres

---
# Service 4: Headless service for redis cluster
apiVersion: v1
kind: Service
metadata:
  name: redis-cluster-headless
  namespace: k8s-tui-test
  labels:
    app: redis-cluster
spec:
  clusterIP: None
  selector:
    app: redis-cluster
    env: test
  ports:
  - port: 6379
    targetPort: 6379
    protocol: TCP
    name: redis

---
# Service 5: Regular ClusterIP for redis
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  namespace: k8s-tui-test
  labels:
    app: redis
spec:
  type: ClusterIP
  selector:
    app: redis
    env: test
  ports:
  - port: 6379
    targetPort: 6379
    protocol: TCP
    name: redis

---
# Service 6: Multi-port service
apiVersion: v1
kind: Service
metadata:
  name: multi-port-service
  namespace: k8s-tui-test
  labels:
    app: nginx
spec:
  type: ClusterIP
  selector:
    app: nginx
    env: test
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
  - port: 443
    targetPort: 80
    protocol: TCP
    name: https

---
# Standalone Pod 1: Running pod with multiple containers
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
  namespace: k8s-tui-test
  labels:
    app: multi-container
    env: test
spec:
  containers:
  - name: main-app
    image: nginx:alpine
    ports:
    - containerPort: 80
  - name: sidecar
    image: busybox:latest
    command: ['sh', '-c', 'while true; do echo "Sidecar running"; sleep 30; done']
  - name: logger
    image: busybox:latest
    command: ['sh', '-c', 'while true; do echo "Logger running"; sleep 60; done']

---
# Standalone Pod 2: Simple running pod
apiVersion: v1
kind: Pod
metadata:
  name: standalone-busybox
  namespace: k8s-tui-test
  labels:
    app: busybox
    env: test
spec:
  containers:
  - name: busybox
    image: busybox:latest
    command: ['sh', '-c', 'echo "Starting..." && sleep 3600']

---
# Standalone Pod 3: Pod that will complete (Succeeded state)
apiVersion: v1
kind: Pod
metadata:
  name: completed-job-pod
  namespace: k8s-tui-test
  labels:
    app: job
    env: test
spec:
  restartPolicy: Never
  containers:
  - name: worker
    image: busybox:latest
    command: ['sh', '-c', 'echo "Job completed successfully" && exit 0']

---
# Deployment with intentional image pull error (to test error states)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: failing-deployment
  namespace: k8s-tui-test
  labels:
    app: failing
    env: test
    status: failing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: failing
      env: test
  template:
    metadata:
      labels:
        app: failing
        env: test
    spec:
      containers:
      - name: app
        image: nonexistent-image:invalid-tag
        imagePullPolicy: Always

---
# Pod with continuous logging (for testing log viewer and follow mode)
apiVersion: v1
kind: Pod
metadata:
  name: verbose-logger
  namespace: k8s-tui-test
  labels:
    app: logger
    env: test
spec:
  containers:
  - name: logger
    image: busybox:latest
    command:
    - sh
    - -c
    - |
      counter=0
      while true; do
        counter=$((counter + 1))
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] Log entry #${counter}: Application running normally"
        sleep 2
        echo "$(date '+%Y-%m-%d %H:%M:%S') [DEBUG] Processing request ${counter}"
        sleep 1
        echo "$(date '+%Y-%m-%d %H:%M:%S') [WARN] Cache miss for key-${counter}"
        sleep 2
        if [ $((counter % 10)) -eq 0 ]; then
          echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] Simulated error for testing (entry ${counter})"
        fi
      done

---
# Pod that crashes and restarts (for testing restart events and previous container logs)
apiVersion: v1
kind: Pod
metadata:
  name: crash-loop-pod
  namespace: k8s-tui-test
  labels:
    app: crasher
    env: test
spec:
  restartPolicy: Always
  containers:
  - name: crasher
    image: busybox:latest
    command:
    - sh
    - -c
    - |
      echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] Container starting..."
      echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] Initializing application..."
      sleep 5
      echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] Fatal error occurred!"
      echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] Stack trace: line 42 in main.sh"
      echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] Exiting with code 1"
      exit 1

---
# Pod with multiple containers for testing container selection in log viewer
apiVersion: v1
kind: Pod
metadata:
  name: log-test-multi
  namespace: k8s-tui-test
  labels:
    app: log-test
    env: test
spec:
  containers:
  - name: frontend
    image: busybox:latest
    command:
    - sh
    - -c
    - |
      while true; do
        echo "[FRONTEND] $(date '+%H:%M:%S') Serving request from user-$((RANDOM % 100))"
        sleep 3
      done
  - name: backend
    image: busybox:latest
    command:
    - sh
    - -c
    - |
      while true; do
        echo "[BACKEND] $(date '+%H:%M:%S') Processing API call to /api/data"
        sleep 5
      done
  - name: database
    image: busybox:latest
    command:
    - sh
    - -c
    - |
      while true; do
        echo "[DATABASE] $(date '+%H:%M:%S') Query executed in $((RANDOM % 100))ms"
        sleep 4
      done
